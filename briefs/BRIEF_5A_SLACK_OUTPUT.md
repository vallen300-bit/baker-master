# BRIEF 5A â€” Slack Output Layer

**Punch:** 5A of 5 (CEO Cockpit)
**Goal:** Replace the basic `{"text": ...}` Slack webhook with a production-grade output layer using Block Kit formatting and real-time alert delivery.

---

## What Exists Today

| File | What it does | Problem |
|------|-------------|---------|
| `triggers/briefing_trigger.py` lines 126-140 | Posts morning briefing to `#cockpit` via webhook | Plain text, truncated to 4000 chars, no formatting |
| `orchestrator/pipeline.py` lines 200-214 | Creates alerts (tier 1/2/3) in PostgreSQL | Alerts are stored but **never delivered** to Slack |
| `config/settings.py` line 142 | `OutputConfig.slack_webhook_url` | Already reads from `.env` âœ… |
| `outputs/__init__.py` | Empty | No output modules exist yet |

**Key gap:** The pipeline creates alerts on every trigger run, but nobody sees them until the next morning briefing. Tier 1 (URGENT) and Tier 2 (IMPORTANT) alerts need real-time Slack delivery.

---

## Files to Create

### 1. `outputs/slack_notifier.py` (~200 lines)

The Slack delivery engine. Handles all webhook communication using Block Kit.

```python
"""
Baker AI â€” Slack Output Layer
Posts formatted messages to #cockpit via incoming webhook.
Uses Slack Block Kit for rich formatting.
"""
```

**Classes/Functions:**

| Name | Purpose |
|------|---------|
| `SlackNotifier` | Main class. Initialized with webhook URL from `config.outputs.slack_webhook_url` |
| `post_alert(alert: dict)` | Format and post a single alert. Takes alert dict with keys: `tier` (1/2/3), `title`, `body`, `action_required`, `contact_name`, `deal_name` |
| `post_briefing(briefing_text: str, date_str: str)` | Format and post the morning briefing as a multi-section Block Kit message |
| `post_pipeline_result(response: SentinelResponse, trigger: TriggerEvent)` | Post a summary when the pipeline processes a trigger (used for email/WhatsApp/meeting triggers) |
| `_post(payload: dict) -> bool` | Internal: POST to webhook. Returns True on success. Uses `httpx` with 10s timeout. Logs failures as warnings (non-fatal). |
| `_truncate(text: str, max_len: int) -> str` | Internal: Truncate text with ellipsis for Block Kit limits (3000 chars per text block) |

**Block Kit Formatting Rules:**

- **Tier 1 (URGENT):** ðŸ”´ Red circle emoji prefix + bold title + section divider. Always includes `action_required` field.
- **Tier 2 (IMPORTANT):** ðŸŸ¡ Yellow circle emoji prefix + bold title.
- **Tier 3 (INFO):** ðŸŸ¢ Green circle â€” **not posted to Slack** (info-only, stays in PostgreSQL). Appears in next morning briefing.
- **Briefing:** Header block with "BAKER MORNING BRIEFING â€” {date}" + section blocks for each section (IMMEDIATE, TODAY, RADAR, OVERNIGHT, DECISIONS PENDING). Use dividers between sections.
- **Pipeline result:** Compact summary: trigger type icon + contact name + 1-line analysis excerpt.

**Block Kit structure for an alert:**
```json
{
  "blocks": [
    {
      "type": "header",
      "text": {"type": "plain_text", "text": "ðŸ”´ URGENT: Payment deadline tomorrow"}
    },
    {
      "type": "section",
      "text": {"type": "mrkdwn", "text": "*Contact:* Mykola\n*Deal:* RG7 Hagenauer\n\nDrawdown request #4 needs approval before 5pm CET."}
    },
    {
      "type": "context",
      "elements": [{"type": "mrkdwn", "text": "Baker AI â€¢ 2026-02-19 08:00 UTC â€¢ Action required âœ…"}]
    }
  ]
}
```

**Block Kit structure for morning briefing:**
```json
{
  "blocks": [
    {
      "type": "header",
      "text": {"type": "plain_text", "text": "â˜€ï¸ BAKER MORNING BRIEFING â€” 2026-02-19"}
    },
    {"type": "divider"},
    {
      "type": "section",
      "text": {"type": "mrkdwn", "text": "*IMMEDIATE (Tier 1)*\nâ€¢ No urgent alerts"}
    },
    {"type": "divider"},
    {
      "type": "section",
      "text": {"type": "mrkdwn", "text": "*TODAY (Tier 2)*\nâ€¢ Review Cupial correspondence (Alric waiting)\nâ€¢ BCOMM license split correction"}
    },
    // ... more sections ...
    {
      "type": "context",
      "elements": [{"type": "mrkdwn", "text": "Generated by Baker AI â€¢ Pipeline v1"}]
    }
  ]
}
```

**Important constraints:**
- Webhook POST limit: 50 blocks per message. If briefing exceeds this, split into multiple POSTs with a "continued..." header.
- Text block limit: 3000 characters. Use `_truncate()`.
- Rate limit: Max 1 message per second per webhook. Add a 1.1s delay between multi-message posts.
- All network errors are **non-fatal** â€” log warning and continue.

---

### 2. `outputs/formatters.py` (~120 lines)

Formatting utilities shared across all output channels.

```python
"""
Baker AI â€” Output Formatters
Multi-format rendering: Slack Block Kit, plain text, markdown.
"""
```

**Functions:**

| Name | Purpose |
|------|---------|
| `format_alert_slack(alert: dict) -> dict` | Returns Block Kit payload for a single alert |
| `format_alert_text(alert: dict) -> str` | Returns plain text (for file/log output) |
| `format_briefing_slack(briefing_text: str, date_str: str) -> dict` | Parse briefing markdown into Block Kit sections |
| `format_briefing_text(briefing_text: str, date_str: str) -> str` | Clean text version (already exists, passthrough) |
| `tier_emoji(tier: int) -> str` | Returns ðŸ”´/ðŸŸ¡/ðŸŸ¢ for tier 1/2/3 |
| `tier_label(tier: int) -> str` | Returns URGENT/IMPORTANT/INFO |
| `parse_briefing_sections(briefing_text: str) -> list[dict]` | Split briefing text on section headers (IMMEDIATE, TODAY, RADAR, OVERNIGHT, DECISIONS PENDING). Returns list of `{"title": ..., "content": ...}` dicts. |

---

## Files to Modify

### 3. `triggers/briefing_trigger.py` â€” Upgrade Slack delivery

**Replace lines 126-140** (the basic Slack POST) with:

```python
# 2. Post to Slack (Block Kit)
try:
    from outputs.slack_notifier import SlackNotifier
    notifier = SlackNotifier()
    notifier.post_briefing(briefing_text, date_str)
except Exception as e:
    logger.warning(f"Could not post briefing to Slack: {e}")
```

This replaces the raw `httpx.post(json={"text": ...})` with the Block Kit formatter.

### 4. `orchestrator/pipeline.py` â€” Wire real-time alerts

**After the store-back section (after line 214)**, add alert delivery:

```python
# 6. Deliver real-time alerts to Slack (Tier 1 + Tier 2 only)
try:
    if response.alerts:
        from outputs.slack_notifier import SlackNotifier
        notifier = SlackNotifier()
        for alert in response.alerts:
            alert_tier = {"urgent": 1, "important": 2, "info": 3}.get(
                alert.get("tier", "info"), 3
            )
            if alert_tier <= 2:  # Only Tier 1 and 2
                notifier.post_alert({
                    "tier": alert_tier,
                    "title": alert.get("title", "Untitled"),
                    "body": alert.get("body", ""),
                    "action_required": alert.get("action_required", False),
                    "contact_name": trigger.contact_name,
                })
except Exception as e:
    logger.warning(f"Store-back: Slack alert delivery failed (non-fatal): {e}")
```

**Placement:** This goes inside the `store_back()` method, after the alerts-to-PostgreSQL block (line 214) and before the trigger result update (line 217). It's wrapped in its own try/except so Slack failures never break the pipeline.

### 5. `outputs/__init__.py` â€” Add exports

```python
from outputs.slack_notifier import SlackNotifier
from outputs.formatters import (
    format_alert_slack,
    format_alert_text,
    format_briefing_slack,
    tier_emoji,
    tier_label,
)
```

---

## Dependencies

Already in `requirements.txt`: `httpx` (used by existing briefing code).

No new dependencies needed.

---

## Test Plan

### Manual tests (run in order):

```bash
# 1. Test formatter output (no network needed)
python -c "
from outputs.formatters import format_alert_slack, tier_emoji
alert = {'tier': 1, 'title': 'Test urgent alert', 'body': 'This is a test', 'action_required': True}
payload = format_alert_slack(alert)
import json; print(json.dumps(payload, indent=2))
"

# 2. Test Slack delivery (posts to real #cockpit)
python -c "
from outputs.slack_notifier import SlackNotifier
n = SlackNotifier()
# Post a test alert
n.post_alert({'tier': 1, 'title': 'TEST â€” Ignore this', 'body': 'Brief 5A delivery test', 'action_required': False})
"

# 3. Test briefing delivery (Block Kit format)
python -c "
from outputs.slack_notifier import SlackNotifier
n = SlackNotifier()
n.post_briefing('IMMEDIATE (Tier 1)\n- No urgent items\n\nTODAY (Tier 2)\n- Review BCOMM contract\n\nRADAR\n- KitzKempi signal monitoring', '2026-02-19')
"

# 4. Run full briefing pipeline (end-to-end)
python cli.py briefing
# Verify: #cockpit shows Block Kit formatted briefing (not plain text)

# 5. Test pipeline alert delivery (simulate email trigger)
python -c "
from orchestrator.pipeline import SentinelPipeline, TriggerEvent
p = SentinelPipeline()
t = TriggerEvent(type='manual', content='Test trigger for alert delivery', source_id='test-5a')
r = p.run(t)
print(f'Alerts generated: {len(r.alerts)}')
# Check #cockpit for any Tier 1/2 alerts
"
```

### Success criteria:
1. `#cockpit` receives Block Kit formatted messages (not plain text)
2. Tier 1 alerts show ðŸ”´ header + bold title + body + context line
3. Tier 2 alerts show ðŸŸ¡ header + bold title + body
4. Tier 3 alerts are **not** posted (only stored in PostgreSQL)
5. Morning briefing shows sectioned layout with dividers
6. All failures are non-fatal (pipeline completes even if Slack is down)

---

## What NOT to build in 5A

- âŒ No Slack Bot (that needs `slack_bot_token` + Socket Mode â€” separate scope)
- âŒ No interactive buttons/actions (read-only output for now)
- âŒ No dashboard (that's 5B + 5C)
- âŒ No push notifications (future scope)
- âŒ No approval workflow via Slack (future: user replies "approve" in thread)

---

## File Checklist

| # | Action | File |
|---|--------|------|
| 1 | CREATE | `outputs/slack_notifier.py` (~200 lines) |
| 2 | CREATE | `outputs/formatters.py` (~120 lines) |
| 3 | MODIFY | `triggers/briefing_trigger.py` (replace lines 126-140) |
| 4 | MODIFY | `orchestrator/pipeline.py` (add ~15 lines after line 214) |
| 5 | MODIFY | `outputs/__init__.py` (add imports) |
