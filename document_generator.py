"""
Baker AI — Document Generator
Generates Word, Excel, PDF, and PowerPoint documents from Baker Scan output.
Called by /api/scan/generate-document endpoint in dashboard.py.
"""
import json
import os
import re
import tempfile
import uuid
from datetime import datetime

# Format-specific imports
from docx import Document
from docx.shared import Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib import colors
from pptx import Presentation
from pptx.util import Inches as PptxInches, Pt as PptxPt

# Storage for generated files — maps file_id to filepath
GENERATED_FILES = {}


def generate_document(content, fmt, title, metadata=None):
    """
    Generate a document in the specified format.

    Args:
        content: str — markdown text (for docx/pdf) or JSON string (for xlsx/pptx)
        fmt: str — "docx", "xlsx", "pdf", or "pptx"
        title: str — document title
        metadata: dict — optional metadata (generated_by, timestamp)

    Returns:
        (file_id, filename, size_bytes)
    """
    generators = {
        "docx": _generate_docx,
        "xlsx": _generate_xlsx,
        "pdf": _generate_pdf,
        "pptx": _generate_pptx,
    }

    if fmt not in generators:
        raise ValueError(f"Unsupported format: {fmt}")

    file_id = str(uuid.uuid4())
    safe_title = re.sub(r'[^\w\s-]', '', title).strip().replace(' ', '_')
    date_str = datetime.utcnow().strftime('%Y-%m-%d')
    filename = f"{safe_title}_{date_str}.{fmt}"

    # Generate into temp directory
    tmp_dir = tempfile.gettempdir()
    filepath = os.path.join(tmp_dir, f"baker_{file_id}.{fmt}")

    generators[fmt](content, title, filepath, metadata)

    size_bytes = os.path.getsize(filepath)
    GENERATED_FILES[file_id] = {
        "filepath": filepath,
        "filename": filename,
        "format": fmt,
        "size_bytes": size_bytes,
        "created_at": datetime.utcnow().isoformat(),
    }

    return file_id, filename, size_bytes


def get_file(file_id):
    """Retrieve file info by ID. Returns None if not found or expired."""
    return GENERATED_FILES.get(file_id)


def cleanup_old_files(max_age_hours=24):
    """Remove files older than max_age_hours. Call periodically."""
    now = datetime.utcnow()
    expired = []
    for fid, info in GENERATED_FILES.items():
        created = datetime.fromisoformat(info["created_at"])
        if (now - created).total_seconds() > max_age_hours * 3600:
            expired.append(fid)
    for fid in expired:
        info = GENERATED_FILES.pop(fid)
        try:
            os.remove(info["filepath"])
        except OSError:
            pass


# ============================================================
# Generator: Word (.docx)
# ============================================================

def _generate_docx(content, title, filepath, metadata):
    """Parse markdown content -> Word document with clean business formatting."""
    doc = Document()

    # Title
    heading = doc.add_heading(title, level=0)
    heading.alignment = WD_ALIGN_PARAGRAPH.LEFT

    # Metadata line
    if metadata:
        meta_para = doc.add_paragraph()
        meta_run = meta_para.add_run(
            f"Generated by {metadata.get('generated_by', 'Baker Scan')} — "
            f"{metadata.get('timestamp', datetime.utcnow().isoformat())}"
        )
        meta_run.font.size = Pt(9)
        meta_run.font.color.rgb = RGBColor(128, 128, 128)
        doc.add_paragraph()  # spacer

    # Parse markdown lines into document elements
    lines = content.split('\n')
    for line in lines:
        stripped = line.strip()
        if not stripped:
            doc.add_paragraph()
            continue

        # Headings
        if stripped.startswith('### '):
            doc.add_heading(stripped[4:], level=3)
        elif stripped.startswith('## '):
            doc.add_heading(stripped[3:], level=2)
        elif stripped.startswith('# '):
            doc.add_heading(stripped[2:], level=1)
        # Bullet points
        elif stripped.startswith('- ') or stripped.startswith('* '):
            doc.add_paragraph(stripped[2:], style='List Bullet')
        # Numbered items
        elif re.match(r'^\d+\.\s', stripped):
            text = re.sub(r'^\d+\.\s', '', stripped)
            doc.add_paragraph(text, style='List Number')
        # Regular paragraph
        else:
            para = doc.add_paragraph()
            # Handle basic bold (**text**) and italic (*text*)
            parts = re.split(r'(\*\*.*?\*\*|\*.*?\*)', stripped)
            for part in parts:
                if part.startswith('**') and part.endswith('**'):
                    run = para.add_run(part[2:-2])
                    run.bold = True
                elif part.startswith('*') and part.endswith('*'):
                    run = para.add_run(part[1:-1])
                    run.italic = True
                else:
                    para.add_run(part)

    doc.save(filepath)


# ============================================================
# Generator: Excel (.xlsx)
# ============================================================

def _generate_xlsx(content, title, filepath, metadata):
    """
    Content should be JSON-parseable with structure:
    { "headers": ["Col A", "Col B"], "rows": [["val1", "val2"], ...] }
    Falls back to parsing markdown tables if JSON parsing fails.
    """
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = title[:31]  # Excel sheet name max 31 chars

    header_font = Font(bold=True, size=11, color="FFFFFF")
    header_fill = PatternFill(start_color="2C3E50", end_color="2C3E50", fill_type="solid")

    try:
        data = json.loads(content) if isinstance(content, str) else content
        headers = data.get("headers", [])
        rows = data.get("rows", [])
    except (json.JSONDecodeError, AttributeError):
        # Fallback: parse markdown table
        headers, rows = _parse_markdown_table(content)

    # Write headers
    for col_idx, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col_idx, value=header)
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal='center')

    # Write data rows
    for row_idx, row_data in enumerate(rows, 2):
        for col_idx, value in enumerate(row_data, 1):
            cell = ws.cell(row=row_idx, column=col_idx, value=value)
            cell.alignment = Alignment(wrap_text=True)

    # Auto-width columns
    for col in ws.columns:
        max_length = 0
        col_letter = col[0].column_letter
        for cell in col:
            if cell.value:
                max_length = max(max_length, len(str(cell.value)))
        ws.column_dimensions[col_letter].width = min(max_length + 4, 50)

    # Metadata row at bottom
    if metadata:
        skip_row = len(rows) + 3
        ws.cell(row=skip_row, column=1,
                value=f"Generated by {metadata.get('generated_by', 'Baker Scan')} — {metadata.get('timestamp', '')}")
        ws.cell(row=skip_row, column=1).font = Font(size=8, color="999999")

    wb.save(filepath)


def _parse_markdown_table(text):
    """Extract headers and rows from a markdown table string."""
    lines = [l.strip() for l in text.strip().split('\n') if l.strip()]
    headers = []
    rows = []
    for line in lines:
        if '|' not in line:
            continue
        cells = [c.strip() for c in line.split('|') if c.strip()]
        # Skip separator rows (---|---)
        if all(re.match(r'^[-:]+$', c) for c in cells):
            continue
        if not headers:
            headers = cells
        else:
            rows.append(cells)
    return headers, rows


# ============================================================
# Generator: PDF (.pdf)
# ============================================================

def _generate_pdf(content, title, filepath, metadata):
    """Markdown content -> clean PDF via reportlab."""
    doc = SimpleDocTemplate(
        filepath, pagesize=A4,
        leftMargin=inch, rightMargin=inch,
        topMargin=inch, bottomMargin=inch
    )

    styles = getSampleStyleSheet()

    # Custom styles
    title_style = ParagraphStyle(
        'BakerTitle', parent=styles['Title'],
        fontSize=18, spaceAfter=12,
        textColor=colors.HexColor('#1a1a2e')
    )
    heading_style = ParagraphStyle(
        'BakerH2', parent=styles['Heading2'],
        fontSize=14, spaceBefore=16, spaceAfter=8,
        textColor=colors.HexColor('#2C3E50')
    )
    body_style = ParagraphStyle(
        'BakerBody', parent=styles['Normal'],
        fontSize=10, leading=14, spaceAfter=6
    )
    meta_style = ParagraphStyle(
        'BakerMeta', parent=styles['Normal'],
        fontSize=8, textColor=colors.HexColor('#999999')
    )

    elements = []

    # Title
    elements.append(Paragraph(title, title_style))

    # Metadata
    if metadata:
        meta_text = (f"Generated by {metadata.get('generated_by', 'Baker Scan')} — "
                     f"{metadata.get('timestamp', '')}")
        elements.append(Paragraph(meta_text, meta_style))

    elements.append(Spacer(1, 12))

    # Parse markdown -> reportlab elements
    lines = content.split('\n')
    for line in lines:
        stripped = line.strip()
        if not stripped:
            elements.append(Spacer(1, 6))
            continue

        if stripped.startswith('## '):
            elements.append(Paragraph(stripped[3:], heading_style))
        elif stripped.startswith('# '):
            elements.append(Paragraph(stripped[2:], title_style))
        elif stripped.startswith('- ') or stripped.startswith('* '):
            bullet_text = f"\u2022 {stripped[2:]}"
            elements.append(Paragraph(bullet_text, body_style))
        else:
            # Convert **bold** to <b>bold</b> for reportlab
            text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', stripped)
            text = re.sub(r'\*(.*?)\*', r'<i>\1</i>', text)
            elements.append(Paragraph(text, body_style))

    doc.build(elements)


# ============================================================
# Generator: PowerPoint (.pptx)
# ============================================================

def _generate_pptx(content, title, filepath, metadata):
    """
    Content should be JSON-parseable with structure:
    { "slides": [{"title": "...", "bullets": ["...", ...]}, ...] }
    Falls back to splitting by ## headings if JSON parsing fails.
    """
    prs = Presentation()
    prs.slide_width = PptxInches(13.333)
    prs.slide_height = PptxInches(7.5)

    try:
        data = json.loads(content) if isinstance(content, str) else content
        slides = data.get("slides", [])
    except (json.JSONDecodeError, AttributeError):
        slides = _parse_markdown_slides(content)

    # Title slide
    title_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_layout)
    slide.shapes.title.text = title
    if slide.placeholders[1]:
        meta_text = "Generated by Baker Scan"
        if metadata and metadata.get('timestamp'):
            meta_text += f" — {metadata['timestamp']}"
        slide.placeholders[1].text = meta_text

    # Content slides
    content_layout = prs.slide_layouts[1]  # Title + Content
    for slide_data in slides:
        slide = prs.slides.add_slide(content_layout)
        slide.shapes.title.text = slide_data.get("title", "")

        body = slide.placeholders[1]
        tf = body.text_frame
        tf.clear()

        bullets = slide_data.get("bullets", [])
        for i, bullet in enumerate(bullets):
            if i == 0:
                tf.paragraphs[0].text = bullet
            else:
                p = tf.add_paragraph()
                p.text = bullet
            tf.paragraphs[-1].font.size = PptxPt(18)

    prs.save(filepath)


def _parse_markdown_slides(text):
    """Split markdown by ## headings into slide structures."""
    slides = []
    current_slide = None

    for line in text.split('\n'):
        stripped = line.strip()
        if stripped.startswith('## '):
            if current_slide:
                slides.append(current_slide)
            current_slide = {"title": stripped[3:], "bullets": []}
        elif current_slide and (stripped.startswith('- ') or stripped.startswith('* ')):
            current_slide["bullets"].append(stripped[2:])
        elif current_slide and stripped and not stripped.startswith('#'):
            current_slide["bullets"].append(stripped)

    if current_slide:
        slides.append(current_slide)

    return slides
