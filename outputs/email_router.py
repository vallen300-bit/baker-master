"""
Baker Email API — send and draft emails via Baker's Gmail account (bakerai200@gmail.com).
Service-level OAuth2 auth (refresh token, no per-user flow).

Routes:
  POST /api/email/send          — send immediately (compose or summary mode)
  POST /api/email/draft         — save as draft for review
  GET  /api/email/inbox         — recent inbox list (metadata + unread_count)
  GET  /api/email/read/{id}     — full message body (MIME parsed, plain text)

Deprecation check: 2026-09-01 (Gmail API v1 + OAuth2 token policy).
"""
import base64
import logging
import os
import re
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from typing import Optional

from fastapi import APIRouter, Depends, Header, HTTPException
from pydantic import BaseModel

logger = logging.getLogger("baker.email")

# ---------------------------------------------------------------------------
# Auth — mirrors dashboard.py verify_api_key (local copy avoids circular import)
# ---------------------------------------------------------------------------
_BAKER_API_KEY = os.getenv("BAKER_API_KEY", "")


async def _verify_key(x_baker_key: str = Header(None, alias="X-Baker-Key")):
    if not _BAKER_API_KEY:
        logger.error("BAKER_API_KEY not configured — email service disabled")
        raise HTTPException(
            status_code=503,
            detail="API key not configured — email service disabled",
        )
    if x_baker_key != _BAKER_API_KEY:
        raise HTTPException(
            status_code=401,
            detail="Invalid or missing API key",
            headers={"WWW-Authenticate": "X-Baker-Key"},
        )


# ---------------------------------------------------------------------------
# Router
# ---------------------------------------------------------------------------
router = APIRouter(tags=["email"])


# ---------------------------------------------------------------------------
# Request model
# ---------------------------------------------------------------------------
class EmailRequest(BaseModel):
    to: Optional[str] = None          # None → dvallen@brisengroup.com (summary mode)
    subject: Optional[str] = None     # None → auto-generated by email_alerts
    body: Optional[str] = None        # None → generate summary content (Type 4)
    custom_note: str = ""             # prepended to summary when body is omitted
    html: bool = False                # only used in compose mode when body is provided


# ---------------------------------------------------------------------------
# Gmail service factory
# ---------------------------------------------------------------------------
def _get_gmail_service():
    """Build Gmail API service using Baker's OAuth2 refresh token."""
    client_id = os.getenv("BAKER_GMAIL_CLIENT_ID", "")
    client_secret = os.getenv("BAKER_GMAIL_CLIENT_SECRET", "")
    refresh_token = os.getenv("BAKER_GMAIL_REFRESH_TOKEN", "")

    if not all([client_id, client_secret, refresh_token]):
        raise RuntimeError(
            "Missing Gmail credentials: BAKER_GMAIL_CLIENT_ID, "
            "BAKER_GMAIL_CLIENT_SECRET, BAKER_GMAIL_REFRESH_TOKEN"
        )

    from google.oauth2.credentials import Credentials
    from googleapiclient.discovery import build

    creds = Credentials(
        token=None,
        refresh_token=refresh_token,
        token_uri="https://oauth2.googleapis.com/token",
        client_id=client_id,
        client_secret=client_secret,
        # scopes omitted — refresh token carries its originally granted scopes
    )
    return build("gmail", "v1", credentials=creds)


# ---------------------------------------------------------------------------
# Message builder
# ---------------------------------------------------------------------------
def _build_raw_message(to: str, subject: str, body: str, html: bool) -> str:
    """Return base64url-encoded RFC 2822 message."""
    sender = os.getenv("BAKER_EMAIL_ADDRESS", "bakerai200@gmail.com")
    if html:
        msg = MIMEMultipart("alternative")
        msg["To"] = to
        msg["From"] = sender
        msg["Subject"] = subject
        msg.attach(MIMEText(body, "html"))
    else:
        msg = MIMEText(body, "plain")
        msg["To"] = to
        msg["From"] = sender
        msg["Subject"] = subject

    raw = base64.urlsafe_b64encode(msg.as_bytes()).decode()
    return raw


# ---------------------------------------------------------------------------
# MIME body extraction helpers (used by /api/email/read)
# ---------------------------------------------------------------------------

def _decode_b64(data: str) -> str:
    """Decode base64url-encoded Gmail body data."""
    try:
        return base64.urlsafe_b64decode(data + "==").decode("utf-8", errors="replace")
    except Exception:
        return ""


def _strip_html(html: str) -> str:
    """Strip HTML tags and decode common entities to plain text."""
    text = re.sub(r"<style[^>]*>.*?</style>", " ", html, flags=re.DOTALL | re.IGNORECASE)
    text = re.sub(r"<script[^>]*>.*?</script>", " ", text, flags=re.DOTALL | re.IGNORECASE)
    text = re.sub(r"<br\s*/?>", "\n", text, flags=re.IGNORECASE)
    text = re.sub(r"<p\s*/?>|</p>", "\n", text, flags=re.IGNORECASE)
    text = re.sub(r"<[^>]+>", "", text)
    text = (text
            .replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">")
            .replace("&nbsp;", " ").replace("&#39;", "'").replace("&quot;", '"'))
    text = re.sub(r"\n{3,}", "\n\n", text)
    return text.strip()


def _extract_body(payload: dict) -> tuple:
    """
    Recursively walk a Gmail MIME payload tree.
    Returns (body_text: str, has_attachments: bool).
    Prefers text/plain; falls back to text/html stripped of tags.
    Handles multipart/mixed, multipart/alternative, multipart/related,
    and nested forwarded messages.
    """
    mime_type = (payload.get("mimeType") or "").lower()
    body_obj = payload.get("body") or {}
    parts = payload.get("parts") or []
    has_attachments = False

    # Leaf nodes with direct body data
    if mime_type == "text/plain":
        data = body_obj.get("data", "")
        return (_decode_b64(data) if data else ""), False

    if mime_type == "text/html":
        data = body_obj.get("data", "")
        return (_strip_html(_decode_b64(data)) if data else ""), False

    # Attachment leaf (has filename, not text)
    if payload.get("filename") and mime_type not in ("text/plain", "text/html"):
        return "", True

    # Multipart — recurse into parts
    if parts:
        plain_text = None
        html_text = None

        for part in parts:
            part_mime = (part.get("mimeType") or "").lower()
            part_body = part.get("body") or {}
            part_filename = part.get("filename") or ""

            if part_mime == "text/plain":
                data = part_body.get("data", "")
                if data and not plain_text:
                    plain_text = _decode_b64(data)

            elif part_mime == "text/html":
                data = part_body.get("data", "")
                if data and not html_text:
                    html_text = _strip_html(_decode_b64(data))

            elif part_mime.startswith("multipart/"):
                nested_text, nested_att = _extract_body(part)
                has_attachments = has_attachments or nested_att
                if nested_text and not plain_text:
                    plain_text = nested_text

            elif part_filename:
                # Named part without text MIME type = attachment
                has_attachments = True

        result = plain_text or html_text or ""
        return result, has_attachments

    return "", has_attachments


# ---------------------------------------------------------------------------
# Endpoints
# ---------------------------------------------------------------------------
@router.post("/api/email/send", dependencies=[Depends(_verify_key)])
async def send_email(req: EmailRequest):
    """
    Send an email from Baker's Gmail account.

    Compose mode (body provided): sends exactly what the Director specified.
      Required: to, subject, body.
      Appends 'Sent via Baker CEO Cockpit on behalf of Dimitry Vallen' footer.

    Summary mode (body omitted): generates a live summary email on demand.
      Optional: to (default dvallen@brisengroup.com), custom_note.
      Calls send_manual_summary_email() from email_alerts.
    """
    if req.body:
        # --- Compose mode (Type 5) ---
        if not req.to or not req.subject:
            raise HTTPException(
                status_code=400,
                detail="to and subject are required when body is provided",
            )
        try:
            from outputs.email_alerts import send_composed_email
            message_id = send_composed_email(req.to, req.subject, req.body)
            if not message_id:
                raise HTTPException(status_code=503, detail="Email service temporarily unavailable")
            logger.info(f"Composed email sent to {req.to}: {req.subject} (id={message_id})")
            return {"status": "sent", "message_id": message_id, "mode": "compose"}
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Compose email failed: {e}")
            raise HTTPException(status_code=503, detail="Email service temporarily unavailable")

    else:
        # --- Summary mode (Type 4) ---
        try:
            from outputs.email_alerts import send_manual_summary_email
            message_id = send_manual_summary_email(
                custom_note=req.custom_note,
                to=req.to,
            )
            if not message_id:
                raise HTTPException(status_code=503, detail="Email service temporarily unavailable")
            logger.info(f"Summary email sent (id={message_id})")
            return {"status": "sent", "message_id": message_id, "mode": "summary"}
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Summary email failed: {e}")
            raise HTTPException(status_code=503, detail="Email service temporarily unavailable")


@router.get("/api/email/inbox", dependencies=[Depends(_verify_key)])
async def get_inbox(
    limit: int = 10,
    sender: str = None,
    label: str = None,
):
    """Return recent emails from Baker's Gmail inbox (metadata only)."""
    try:
        service = _get_gmail_service()

        # Build Gmail search query
        query_parts = []
        if sender:
            query_parts.append(f"from:{sender}")
        if label:
            query_parts.append(f"label:{label}")
        query_string = " ".join(query_parts) if query_parts else None

        list_kwargs = {"userId": "me", "maxResults": limit}
        if query_string:
            list_kwargs["q"] = query_string

        list_result = service.users().messages().list(**list_kwargs).execute()
        messages = list_result.get("messages", [])

        results = []
        unread_count = 0
        for msg in messages:
            msg_data = service.users().messages().get(
                userId="me",
                id=msg["id"],
                format="metadata",
                metadataHeaders=["From", "To", "Subject", "Date"],
            ).execute()

            headers = {h["name"]: h["value"] for h in msg_data.get("payload", {}).get("headers", [])}
            label_ids = msg_data.get("labelIds", [])
            is_unread = "UNREAD" in label_ids
            if is_unread:
                unread_count += 1

            results.append({
                "id": msg_data.get("id"),
                "threadId": msg_data.get("threadId"),
                "from": headers.get("From", ""),
                "to": headers.get("To", ""),
                "subject": headers.get("Subject", ""),
                "date": headers.get("Date", ""),
                "snippet": msg_data.get("snippet", ""),
                "unread": is_unread,
            })

        logger.info(f"Inbox fetched: {len(results)} messages, {unread_count} unread (limit={limit})")
        return {"messages": results, "count": len(results), "unread_count": unread_count}

    except Exception as e:
        logger.error(f"Gmail inbox fetch failed: {e}")
        raise HTTPException(status_code=503, detail="Email service temporarily unavailable")


@router.get("/api/email/read/{message_id}", dependencies=[Depends(_verify_key)])
async def read_email(message_id: str):
    """
    Fetch the full body of a single Gmail message.
    Uses format='full' to retrieve the complete MIME tree.
    Prefers text/plain; falls back to text/html stripped of tags.
    Handles multipart/mixed, multipart/alternative, and forwarded messages.
    Falls back to snippet with body_parse_error=true if MIME parsing yields nothing.
    """
    try:
        service = _get_gmail_service()
        msg_data = service.users().messages().get(
            userId="me",
            id=message_id,
            format="full",
        ).execute()

        payload = msg_data.get("payload") or {}
        headers = {h["name"]: h["value"] for h in payload.get("headers", [])}
        label_ids = msg_data.get("labelIds", [])
        snippet = msg_data.get("snippet", "")

        # Parse MIME tree
        body_parse_error = False
        try:
            body_text, has_attachments = _extract_body(payload)
        except Exception as parse_err:
            logger.warning(f"MIME parse error for {message_id}: {parse_err}")
            body_text = ""
            has_attachments = False
            body_parse_error = True

        # Fallback to snippet if body is empty
        if not body_text:
            body_text = snippet
            body_parse_error = True

        logger.info(f"Email read: {message_id} ({len(body_text)} chars, attachments={has_attachments})")
        result = {
            "id": msg_data.get("id"),
            "threadId": msg_data.get("threadId"),
            "from": headers.get("From", ""),
            "to": headers.get("To", ""),
            "subject": headers.get("Subject", ""),
            "date": headers.get("Date", ""),
            "body": body_text,
            "has_attachments": has_attachments,
            "labels": label_ids,
        }
        if body_parse_error:
            result["body_parse_error"] = True
        return result

    except Exception as e:
        logger.error(f"Gmail read failed for {message_id}: {e}")
        raise HTTPException(status_code=503, detail="Email service temporarily unavailable")


@router.post("/api/email/draft", dependencies=[Depends(_verify_key)])
async def create_draft(req: EmailRequest):
    """Create a draft in Baker's Gmail account."""
    if not req.to or not req.subject or not req.body:
        raise HTTPException(status_code=400, detail="to, subject, and body are required")

    try:
        service = _get_gmail_service()
        raw = _build_raw_message(req.to, req.subject, req.body, req.html)
        result = service.users().drafts().create(
            userId="me",
            body={"message": {"raw": raw}},
        ).execute()
        msg = result.get("message", {})
        logger.info(f"Draft created for {req.to}: {req.subject} (draft_id={result.get('id')})")
        return {
            "status": "drafted",
            "draft_id": result.get("id"),
            "message_id": msg.get("id"),
        }
    except Exception as e:
        logger.error(f"Gmail draft failed: {e}")
        raise HTTPException(status_code=503, detail="Email service temporarily unavailable")
